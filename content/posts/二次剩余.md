---
title: "二次剩余 - Cipolla/Tonelli-Shanks"
date: 2021-08-30 20:03:56
draft: false
slug: a8861495

author: "Kenshin2438"
description: ""
categories:
  - Number Theory
tags:
  - Cipolla
  - Tonelli-Shanks

weight: false
math: true
comments: true

cover:
  image: "" # image path/url
  alt: "" # alt text
  caption: "" # display caption under cover
  relative: false
---

对于二次剩余式 $$x^2\equiv n\pmod p$$
其中$p$为奇素数，且$p \nmid n$，求$x$。

<!--more-->

## Cipolla算法

$Cipolla$和之前就写过的三次剩余是同一个思路，所以我在写完$Cipolla$后感觉好像什么都没变。

构造一个环

$$R=\frac{\mathbb{Z}_p[x]}{x^2-a}=\set{\alpha+\beta Y | \alpha,\beta,\in\mathbb{Z}_p,Y^2=a}$$

可知，

对于$z\in R$，即$z=\alpha+\beta Y$，有$z^{p-1}\equiv 1\pmod{p}$

如果$z^{\frac{p-1}{2}}=\beta_0 Y$，则有$(\beta_0 Y)^2\equiv\beta_0^2a\equiv1\pmod{p}$，即$\sqrt{a}\equiv\beta_0^{-1}\pmod{p}$

(~~我直接复制过来的，嘿嘿~~)

---

代码如下：

```cpp
int qpow(int x, int n, int mod, int res = 1) {
	for (x %= mod; n; n >>= 1, x = 1LL * x * x % mod)
		!(n & 1) ?: res = 1LL * res * x % mod;
	return res;
}

struct R {
	int s[2], m, p;
	R() { s[0] = 1, s[1] = 0; }
	void New() { s[0] = rand() % p, s[1] = rand() % p; }
	void ins(int _m, int _p) { m = _m, p = _p; }
	void set(int _s[]) { mempcpy(s, _s, sizeof s); }
	void mul(R b) {
		int _s[2] = {0, 0};
		for (int i = 0; i < 2; i++) for (int j = 0; j < 2; j++)
			if (i + j < 2) {
				_s[i + j] = (_s[i + j] + 1LL * s[i] * b.s[j] % p) % p 
			} else { 
				_s[i + j - 2] = (_s[i + j - 2] + 1LL * s[i] * b.s[j] % p * m % p) % p
			}
		return set(_s);
	}
	void pow(int n) {
		R x, res; x.ins(m, p), res.ins(m, p);
		for (x.set(s); n; n >>= 1, x.mul(x)) if (n & 1) res.mul(x);
		set(res.s);
	}
} F;

void Cipolla(int n, int p) {
	int t = p - 1 >> 1, r1, r2; F.ins(n, p);
	while (true) {
		F.New(), F.pow(t);
		if (!F.s[0] && F.s[1]) { r1 = qpow(F.s[1], p - 2, p); break; }
	} r2 = p - r1;
	if (r1 > r2) r1 ^= r2 ^= r1 ^= r2; 
	printf("%d %d\n", r1, r2);
}
```

## Tonelli-Shanks算法
(来自柯召的《初等数论》)

+ $p\mod 4=3$

由于$n^{\frac{p-1}{2}}\equiv 1\pmod p$，得到$(\pm n^{\frac{p+1}{4}})^2\equiv n\pmod p$。

---

+ $p\mod 8=5$

先求$n=-1$的解。

由威尔逊定理有$-1\equiv (p-1)! \pmod p$，对于右侧有：

$$1\times2\times\cdots\times(\frac{p-1}{2})\times(p-\frac{p-1}{2})\times\cdots\times(p-1)\equiv\left((\frac{p-1}{2})!\right)^2\pmod p$$

> $4\mid (p-1)$，所以负号没了。

同样的，由于$n^{\frac{p-1}{2}}\equiv 1\pmod p$，我们得到

$n$适合$n^{\frac{p-1}{4}}\equiv 1\pmod p$或$n^{\frac{p-1}{4}}\equiv-1\pmod p$

1. $n^{\frac{p-1}{4}}\equiv 1\pmod p$，有$(n^{\frac{p+3}{8}})^2\equiv n\pmod p$
2. $n^{\frac{p-1}{4}}\equiv-1\pmod p$，有$((\frac{p-1}{2})!\times n^{\frac{p+3}{8}})^2\equiv n\pmod p$

---

+ $p\mod 8=1$

> 设$p\equiv 1\pmod 8,(\frac{n}{p})=1,(\frac{N}{p})=-1$，则同余式有解
> $$\pm n^{\frac{h+1}{2}}N^{s_k}$$
> 其中$p=2^kh+1,2\nmid h,s_k\geq0$是某个整数。

证明：设$p=2^kh+1,k\geq3,2\nmid h$。

由于$(\frac{n}{p})=1, (\frac{N}{p})=-1$，我们得出

$$n^{2^{k-1}h}\equiv 1\pmod p$$
$$N^{2^{k-1}h}\equiv-1\pmod p$$

因此下面的两个同余式有且只有一个成立

$$n^{2^{k-2}h}\equiv 1\pmod p$$
$$n^{2^{k-2}h}\equiv-1\pmod p$$

故有非负整数$s_2=hf$（$f=0$或$1$）使

$$n^{2^{k-2}h}\times N^{2^{k-1}s_2}\equiv1\pmod p$$

成立。

于是下面两个同余式有且只有一个成立

$$n^{2^{k-3}h}\times N^{2^{k-2}s_2}\equiv 1\pmod p$$
$$n^{2^{k-3}h}\times N^{2^{k-2}s_2}\equiv-1\pmod p$$

故又有非负的$s_3=s_2+2hf_1$（$f_1=0$或$1$）满足下式

$$n^{2^{k-3}h}\times N^{2^{k-2}s_3}\equiv1\pmod p$$

因为$k$是有限整数，故必有一非负的$s_k$使得

$$n^h\times N^{2s_k}\equiv1\pmod p$$

故

$$n^{h+1}N^{2s_k}\equiv n\pmod p$$

即

$$\left(n^{\frac{h+1}{2}}N^{s_k}\right)^2\equiv n\pmod p$$
